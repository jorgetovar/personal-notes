# Pragmatic Programmer

## Pragmatic philosophy

 - Your life it's your life
   * Craftmanship 
   * Early adopter 
 - Responsability
   * Offer options 
 - Software Entropy
   * Simplicity
   * Maintainance
 - Good enough software
   * Quality as requirement
 - Your knowdledge portafolio:
   * **Investment in knowdledge always pays the best interest**
   * Read notechnical books
   * Read conceptual books
   * Learn one new lenguage every year
 - Communicate


## Pramatic approach

 - The essence of good design : ETC
 - DRY : Code, Data, Documentation (Knowledge)
   * Don't abstract to early, wait until you have copied and pasted a couple of times, examples are needed to create good abstractions
 - Orthogonality:
   * Eliminate effects between unrelated things
   * Undestandable, and easier to debug, test and mantain
   * Design patterns
   * SOLID
   * Prefer composition and FP lenguages
 - Reversability:
   * Flexible architecture
   * Have options
 - Tracer bullets:
   * Code lean and complete
   * Find the target
 - Prototypes and post-it note:
   * Information gathering
   * Is coupling minimized
   * Collaborations between components well-defined
   * Responsabilities
   * Interfaces and data clear and available

 - Domain lenguages:
   * Program close to the problem domain //TODO3 learn DSL
 - Estimation:
   *  I'll back yo you
   * optimistic, most likely and pessimistic
   * model building: someone that already did it 

## Basic Tools

Be more productive with your tools

 - The power of plain text:
   * Self describing data
 - Shell games //TODO1 shell training
 - Power Editing //TODO0 Intellij shortcuts